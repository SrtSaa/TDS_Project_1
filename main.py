import os
import base64
import time
from fastapi import FastAPI, Request, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import List, Optional
import requests
from github import Github, GithubException
from dotenv import load_dotenv
import google.generativeai as genai

# --- Load Environment Variables ---
# For local testing, create a .env file. For Hugging Face, set these in the Space secrets.
load_dotenv()

MY_SECRET = os.getenv("MY_SECRET")
GITHUB_PAT = os.getenv("GITHUB_PAT")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")

# A startup check to ensure essential variables are loaded.
if not all([MY_SECRET, GITHUB_PAT, GOOGLE_API_KEY]):
    print("WARNING: One or more environment variables (MY_SECRET, GITHUB_PAT, GOOGLE_API_KEY) are not set.")

# --- Pydantic Models for Data Validation ---
class Attachment(BaseModel):
    name: str
    url: str

class RequestModel(BaseModel):
    email: str
    secret: str
    task: str
    round: int
    nonce: str
    brief: str
    checks: List[str]
    evaluation_url: str
    attachments: Optional[List[Attachment]] = None

class EvaluationPayload(BaseModel):
    email: str
    task: str
    round: int
    nonce: str
    repo_url: str
    commit_sha: str
    pages_url: str

# --- FastAPI App Initialization ---
app = FastAPI()

# --- GitHub Helper Functions ---

def get_existing_code_from_github(repo_name: str, file_path: str) -> Optional[str]:
    """Fetches the content of a file from a GitHub repo if it exists."""
    print(f"Attempting to fetch existing file '{file_path}' from repo '{repo_name}'...")
    try:
        g = Github(GITHUB_PAT)
        user = g.get_user()
        repo = user.get_repo(repo_name)
        contents = repo.get_contents(file_path)
        return contents.decoded_content.decode("utf-8")
    except GithubException:
        print(f"Could not retrieve existing file '{file_path}'. It may not exist yet.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred while fetching code: {e}")
        return None

def setup_github_repo(repo_name: str, code: str, brief: str, round_num: int):
    """Creates or updates a GitHub repository, its files, and enables Pages."""
    print(f"Setting up GitHub repo '{repo_name}' for round {round_num}.")
    g = Github(GITHUB_PAT)
    user = g.get_user()
    repo = None

    try:
        repo = user.get_repo(repo_name)
        print("Found existing repo.")
    except GithubException:
        if round_num > 1:
            print(f"Warning: Repo '{repo_name}' not found for Round 2. Creating it now.")
        print(f"Creating new repo: {repo_name}")
        repo = user.create_repo(repo_name, private=False, auto_init=False)

    # --- Generate Comprehensive README Content ---
    pages_url = f"https://{user.login}.github.io/{repo_name}/"
    
    readme_content = f"""# {repo_name}

## 1. Summary

This project is a single-page web application generated to fulfill the following brief:

> {brief}

This application was built and deployed automatically as part of a multi-round, automated evaluation task for **Round {round_num}**. The entire frontend is self-contained within the `index.html` file.

[Image of a modern web application interface]

## 2. Setup

No local setup is required to run this application. It is designed for direct deployment and viewing on GitHub Pages. All necessary dependencies (such as CSS frameworks or external libraries) are loaded from Content Delivery Networks (CDNs).

## 3. Usage

To use the application, navigate to the deployed GitHub Pages URL:

[**View the live application here**]({pages_url})

The page will load, and the application will be ready for interaction as described in the summary.

## 4. Code Explanation

The entire application logic, styling, and structure are contained within the `index.html` file.

-   **HTML**: Provides the fundamental structure and content of the page, including forms, buttons, and containers as specified in the brief.
-   **CSS**: Styling is either included within `<style>` tags or loaded from a CDN (e.g., Bootstrap) as required.
-   **JavaScript**: All dynamic functionality, including event handling (e.g., button clicks, user input) and API interactions (`fetch` calls), is handled by plain JavaScript embedded within `<script>` tags.

The code was generated by an LLM to specifically address the project requirements and pass a series of automated checks.

## 5. License

This project is licensed under the **MIT License**. The full license text is available in the [LICENSE](LICENSE) file in this repository.
"""

    # Create or update LICENSE file
    try:
        repo.get_contents("LICENSE")
    except GithubException:
        print("Creating MIT LICENSE file.")
        with open("MIT_LICENSE_TEMPLATE.txt", "r") as f:
            license_text = f.read()
        repo.create_file("LICENSE", "feat: Add MIT License", license_text)

    # Create or update README.md
    try:
        contents = repo.get_contents("README.md")
        repo.update_file(contents.path, f"docs: Update README.md for round {round_num}", readme_content, contents.sha)
        print("Updated README.md")
    except GithubException:
        repo.create_file("README.md", "docs: Create README.md", readme_content)
        print("Created README.md")

    # Create or update index.html
    try:
        contents = repo.get_contents("index.html")
        commit = repo.update_file(contents.path, f"feat: Update app for round {round_num}", code, contents.sha)
        print("Updated index.html")
    except GithubException:
        commit = repo.create_file("index.html", f"feat: Create app for round {round_num}", code)
        print("Created index.html")

    commit_sha = commit['commit'].sha
    print(f"Pushed commit: {commit_sha}")

    # Enable GitHub Pages
    print("Enabling GitHub Pages...")
    try:
        pages_payload = {"source": {"branch": "main", "path": "/"}}
        repo._requester.requestJsonAndCheck(
            "POST", f"/repos/{repo.owner.login}/{repo.name}/pages",
            input=pages_payload, headers={'Accept': 'application/vnd.github.v3+json'}
        )
        print("GitHub Pages build triggered successfully.")
    except GithubException as e:
        if e.status == 409: # 409 Conflict means it's already enabled
            print("GitHub Pages are already enabled for this repository.")
        else:
            print(f"An error occurred while enabling GitHub Pages: {e}")

    time.sleep(20) # A short delay to allow pages to build
    return repo.html_url, commit_sha, pages_url

# --- LLM Code Generation ---

def generate_code_with_llm(brief: str, checks: List[str], attachments: List[Attachment], existing_code: Optional[str] = None) -> str:
    """Generates or revises HTML code using the AIPipe LLM."""
    print("Preparing prompt for LLM...")
    attachment_content = ""
    if attachments:
        for att in attachments:
            try:
                header, encoded = att.url.split(",", 1)
                data = base64.b64decode(encoded).decode("utf-8")
                attachment_content += f"\n\n--- Attachment: {att.name} ---\n{data}\n--- End Attachment ---"
            except Exception as e:
                print(f"Could not decode attachment {att.name}: {e}")

    formatted_checks = "\n- ".join(checks)

    if existing_code:
        prompt = f"""You are an expert web developer specializing in revising code. Your task is to modify the provided `index.html` file based on a new brief.

**Brief for Revision:**
{brief}

**Evaluation Checks for This Round:**
- {formatted_checks}
{attachment_content}

**Existing `index.html` Code to Revise:**
```html
{existing_code}
```

**Instructions:**
1.  Carefully analyze the new brief and the existing code.
2.  Modify the code to implement the requested changes and pass the new evaluation checks.
3.  Output ONLY the new, complete, and raw code for the `index.html` file. Do not include any explanations, greetings, or markdown formatting like ```html.
"""
    else:
        prompt = f"""You are an expert web developer who creates single-file, dependency-free HTML applications. Your task is to generate a single `index.html` file that fulfills the user's request.

**Brief:**
{brief}

**Evaluation Checks:**
The application will be evaluated against these checks:
- {formatted_checks}
{attachment_content}

**Instructions:**
1.  Write all necessary HTML, CSS, and JavaScript into a single `index.html` file.
2.  Do not use any external files unless explicitly asked for (like a CDN).
3.  Ensure your code directly addresses the brief and will pass the evaluation checks.
4.  Output ONLY the raw code for the `index.html` file. Do not include any explanations, greetings, or markdown formatting like ```html.
"""

    try:
        genai.configure(api_key=GOOGLE_API_KEY)
        model = genai.GenerativeModel('gemini-pro-latest')
        response = model.generate_content(prompt)
        generated_code = response.text

        if generated_code.startswith("```html"):
            generated_code = generated_code.split("\n", 1)[1]
        if generated_code.endswith("```"):
            generated_code = generated_code.rsplit("\n", 1)[0]
        print("Successfully generated code.")
        return generated_code.strip()
    except requests.exceptions.RequestException as e:
        error_message = f"Error calling LLM API: {e}"
        if e.response is not None:
            error_message += f"\nResponse Status: {e.response.status_code}"
            try:
                error_message += f"\nResponse Body: {e.response.json()}"
            except Exception:
                error_message += f"\nResponse Body: {e.response.text}"
        print(error_message)
        return f"<html><body><h1>Error</h1><p>Failed to generate code via LLM. See server logs for details.</p></body></html>"

# --- Evaluation Notification ---

def notify_evaluation_server(url: str, payload: EvaluationPayload):
    """POSTs the final results to the evaluation URL with exponential backoff."""
    print(f"Notifying evaluation server at {url} with final status...")
    headers = {"Content-Type": "application/json"}
    delays = [1, 2, 4, 8, 16] 

    for i, delay in enumerate(delays):
        try:
            response = requests.post(url, json=payload.dict(), headers=headers, timeout=15)
            if response.status_code == 200:
                print("Successfully notified evaluation server of final status.")
                return
            else:
                print(f"Attempt {i+1}: Evaluation server returned status {response.status_code}. Retrying in {delay}s...")
        except requests.exceptions.RequestException as e:
            print(f"Attempt {i+1}: Failed to notify evaluation server: {e}. Retrying in {delay}s...")
        time.sleep(delay)
    print("Failed to notify evaluation server after multiple retries.")

# --- Main Background Task Orchestrator ---

def process_build_request(request: RequestModel):
    """The main background task to handle a build or revise request."""
    try:
        print(f"BACKGROUND: Processing task '{request.task}' for round {request.round}...")
        repo_name = request.task

        if request.round == 1:
            print("BACKGROUND: Round 1: Creating a new application.")
            generated_code = generate_code_with_llm(request.brief, request.checks, request.attachments or [])
        elif request.round == 2:
            print("BACKGROUND: Round 2: Revising the existing application.")
            existing_code = get_existing_code_from_github(repo_name, "index.html")
            if not existing_code:
                 print("BACKGROUND: Warning: Round 2 but no existing code found. Creating from scratch.")
            generated_code = generate_code_with_llm(request.brief, request.checks, request.attachments or [], existing_code=existing_code)
        
        repo_url, commit_sha, pages_url = setup_github_repo(
            repo_name=repo_name,
            code=generated_code,
            brief=request.brief,
            round_num=request.round
        )

        payload = EvaluationPayload(
            email=request.email, task=request.task, round=request.round, nonce=request.nonce,
            repo_url=repo_url, commit_sha=commit_sha, pages_url=pages_url,
        )
        notify_evaluation_server(request.evaluation_url, payload)
        print(f"BACKGROUND: Finished processing task '{request.task}'.")
    except Exception as e:
        print(f"FATAL ERROR in background task for '{request.task}': {e}")

# --- FastAPI Endpoints ---

@app.get("/")
def read_root():
    """Root endpoint to confirm the server is running."""
    return {"status": "API is running."}

@app.post("/api-endpoint")
async def handle_build_request(request: RequestModel, background_tasks: BackgroundTasks):
    """
    Accepts the build/revise request, validates the secret, and queues the job to run in the background.
    Responds immediately with 200 OK.
    """
    if request.secret != MY_SECRET:
        raise HTTPException(status_code=403, detail="Invalid secret")

    background_tasks.add_task(process_build_request, request)

    return {"status": "Request received. Processing will continue in the background."}

